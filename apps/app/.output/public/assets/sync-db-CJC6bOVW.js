import{Q as L,c as P,d as H,e as J,r as V,j as l}from"./main-DJAnHGiT.js";import{S as X,A as Y}from"./sidebar-7jcn3lOG.js";import{I as Z}from"./input-CFMIqzE9.js";import{fW as _}from"./button-BDX-2Pnw.js";import{C as ee}from"./checkbox-BbxIDuh8.js";import{T as te,c as re,u as ne,e as oe}from"./useLiveQuery-DgtjeeQe.js";import{Q as se}from"./queryObserver-BnkVCiPn.js";import"./index-CLOoIZyZ.js";class y extends te{constructor(e){super(e),this.name="QueryCollectionError"}}class ae extends y{constructor(){super("[QueryCollection] queryKey must be provided."),this.name="QueryKeyRequiredError"}}class ie extends y{constructor(){super("[QueryCollection] queryFn must be provided."),this.name="QueryFnRequiredError"}}class ce extends y{constructor(){super("[QueryCollection] queryClient must be provided."),this.name="QueryClientRequiredError"}}class le extends y{constructor(){super("[QueryCollection] getKey must be provided."),this.name="GetKeyRequiredError"}}class ue extends y{constructor(){super("Collection must be in 'ready' state for manual sync operations. Sync not initialized yet."),this.name="SyncNotInitializedError"}}class de extends y{constructor(e){super(`Duplicate key '${e}' found within batch operations`),this.name="DuplicateKeyInBatchError"}}class pe extends y{constructor(e){super(`Update operation: Item with key '${e}' does not exist`),this.name="UpdateOperationItemNotFoundError"}}class ye extends y{constructor(e){super(`Delete operation: Item with key '${e}' does not exist`),this.name="DeleteOperationItemNotFoundError"}}const f=new WeakMap;function he(o,e){const s=Array.isArray(o)?o:[o],r=[];for(const n of s)if(n.type==="delete"){const t=Array.isArray(n.key)?n.key:[n.key];for(const a of t)r.push({type:"delete",key:a})}else{const t=Array.isArray(n.data)?n.data:[n.data];for(const a of t){let h;if(n.type==="update")h=e.getKey(a);else{const E=e.collection.validateData(a,n.type==="upsert"?"insert":n.type);h=e.getKey(E)}r.push({type:n.type,key:h,data:a})}}return r}function fe(o,e){const s=new Set;for(const r of o){if(s.has(r.key))throw new de(r.key);if(s.add(r.key),r.type==="update"){if(!e.collection.has(r.key))throw new pe(r.key)}else if(r.type==="delete"&&!e.collection.has(r.key))throw new ye(r.key)}}function w(o,e){const s=he(o,e);fe(s,e),e.begin();for(const n of s)switch(n.type){case"insert":{const t=e.collection.validateData(n.data,"insert");e.write({type:"insert",value:t});break}case"update":{const a={...e.collection.get(n.key),...n.data},h=e.collection.validateData(a,"update",n.key);e.write({type:"update",value:h});break}case"delete":{const t=e.collection.get(n.key);e.write({type:"delete",value:t});break}case"upsert":{const t=e.collection.validateData(n.data,e.collection.has(n.key)?"update":"insert",n.key);e.collection.has(n.key)?e.write({type:"update",value:t}):e.write({type:"insert",value:t});break}}e.commit();const r=e.collection.toArray;e.queryClient.setQueryData(e.queryKey,r)}function me(o){function e(){const s=o();if(!s)throw new ue;return s}return{writeInsert(s){const r={type:"insert",data:s},n=e(),t=f.get(n);if(t?.isActive){t.operations.push(r);return}w(r,n)},writeUpdate(s){const r={type:"update",data:s},n=e(),t=f.get(n);if(t?.isActive){t.operations.push(r);return}w(r,n)},writeDelete(s){const r={type:"delete",key:s},n=e(),t=f.get(n);if(t?.isActive){t.operations.push(r);return}w(r,n)},writeUpsert(s){const r={type:"upsert",data:s},n=e(),t=f.get(n);if(t?.isActive){t.operations.push(r);return}w(r,n)},writeBatch(s){const r=e(),n=f.get(r);if(n?.isActive)throw new Error("Cannot nest writeBatch calls. Complete the current batch before starting a new one.");const t={operations:[],isActive:!0};f.set(r,t);try{const a=s();if(a&&typeof a=="object"&&"then"in a&&typeof a.then=="function")throw new Error("writeBatch does not support async callbacks. The callback must be synchronous.");t.operations.length>0&&w(t.operations,r)}finally{t.isActive=!1,f.delete(r)}}}}function we(o){const{queryKey:e,queryFn:s,queryClient:r,enabled:n,refetchInterval:t,retry:a,retryDelay:h,staleTime:E,getKey:v,onInsert:q,onUpdate:A,onDelete:Q,meta:U,...N}=o;if(!e)throw new ae;if(!s)throw new ie;if(!r)throw new ce;if(!v)throw new le;const B=u=>{const{begin:c,write:d,commit:I,markReady:k,collection:z}=u,M={queryKey:e,queryFn:s,meta:U,enabled:n,refetchInterval:t,retry:a,retryDelay:h,staleTime:E,structuralSharing:!0,notifyOnChangeProps:"all"},S=new se(r,M),O=g=>{if(g.isSuccess){const C=g.data;if(!Array.isArray(C)||C.some(i=>typeof i!="object")){console.error("[QueryCollection] queryFn did not return an array of objects. Skipping update.",C);return}const K=new Map(z.syncedData),D=new Map;C.forEach(i=>{const p=v(i);D.set(p,i)}),c();const $=(i,p)=>{const m=Object.keys(i),G=Object.keys(p);return m.length!==G.length?!1:m.every(x=>typeof i[x]=="function"?!0:i[x]===p[x])};K.forEach((i,p)=>{const m=D.get(p);m?$(i,m)||d({type:"update",value:m}):d({type:"delete",value:i})}),D.forEach((i,p)=>{K.has(p)||d({type:"insert",value:i})}),I(),k()}else g.isError&&(console.error(`[QueryCollection] Error observing query ${String(e)}:`,g.error),k())},W=S.subscribe(O);return O(S.getCurrentResult()),async()=>{W(),await r.cancelQueries({queryKey:e}),r.removeQueries({queryKey:e})}},b=async()=>r.refetchQueries({queryKey:e});let R=null;const F=u=>{const{begin:c,write:d,commit:I,collection:k}=u;return R={collection:k,queryClient:r,queryKey:e,getKey:v,begin:c,write:d,commit:I},B(u)},T=me(()=>R);return{...N,getKey:v,sync:{sync:F},onInsert:q?async u=>{const c=await q(u)??{};return c.refetch!==!1&&await b(),c}:void 0,onUpdate:A?async u=>{const c=await A(u)??{};return c.refetch!==!1&&await b(),c}:void 0,onDelete:Q?async u=>{const c=await Q(u)??{};return c.refetch!==!1&&await b(),c}:void 0,utils:{refetch:b,...T}}}const ve=new L,j=re(we({queryClient:ve,queryKey:["todos"],queryFn:async()=>H(),getKey:o=>o.id,onInsert:async({transaction:o})=>{const{modified:e}=o.mutations[0];await P({data:{title:e.title}})}}));function Re(){const{user:o}=J.useLoaderData(),{data:e}=ne(t=>t.from({todo:j}).where(({todo:a})=>oe(a.completed,!1)).orderBy(({todo:a})=>a.createdAt,"desc")),[s,r]=V.useState(""),n=t=>{t.preventDefault(),j.insert({id:crypto.randomUUID(),createdAt:new Date,completed:!1,userId:o.id,title:s}),r("")};return l.jsxs(X,{children:[l.jsx(Y,{}),l.jsxs("main",{className:"p-4",children:[l.jsx("h1",{className:"text-2xl font-bold",children:"Sync with TanStack DB"}),l.jsx("p",{className:"mb-4",children:"A simple todo list built with TanStack DB."}),l.jsx("div",{className:"mb-4",children:e.map(t=>l.jsxs("div",{className:"flex items-center gap-2",children:[l.jsx(ee,{}),t.title]},t.id))}),l.jsxs("form",{onSubmit:n,className:"flex gap-2 p-3 bg-muted w-full rounded-lg",children:[l.jsx(Z,{value:s,onChange:t=>r(t.target.value),className:"bg-white"}),l.jsx(_,{type:"submit",children:"Add"})]})]})]})}export{Re as component};
